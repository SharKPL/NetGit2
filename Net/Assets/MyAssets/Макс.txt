Система управления временем в игре позволяет игроку временно изменять скорость течения времени, останавливая его или замедляя, и затем возвращаться к нормальному состоянию. Это включает в себя управление объектами, находящимися под влиянием манипуляций временем, а также соответствующими визуальными и аудиоэффектами. Система обеспечивает плавные переходы между различными состояниями времени, а также позволяет исключать отдельные объекты из этих манипуляций. Рассмотрим основные компоненты системы управления временем, представленные в таблице 4 и их взаимодействие, представленное на рисунке 4.




Таблица 4 – Описание классов системы добивания
Класс	Роль
TimeManager	Центральный класс, управляющий состоянием времени в игре.
TimeBody	Класс, обрабатывающий объекты, на которые влияет манипуляция временем.
ITimeAffected	Интерфейс, определяющий на какой класс может влиять манипуляция временем

 
Рисунок 4 – Диаграмма классов управления временем

TimeManager, продемонстрированный в листинге А.12, реализует паттерн одиночка, чтобы гарантировать наличие только одного экземпляра в игре. Он также подключает обработчики событий для ввода игрока, чтобы реагировать на команды остановки и замедления времени.
При получении команды на остановку времени TimeManager проверяет, не остановлено ли уже время или не замедлено ли оно. Если время не остановлено и не замедлено, запускается процесс остановки времени: флаг IsTimeStopped устанавливается в true, все зарегистрированные объекты переводятся в состояние остановки времени, активируется специальная камера, изменяется профиль постобработки и высота звука. Также запускается корутина, которая через некоторое время восстанавливает нормальное течение времени.
При замедлении времени аналогично проверяется текущее состояние времени. Если время не остановлено и не замедлено, процесс замедления времени включает установку флага IsTimeSlowed в true, перевод объектов в состояние замедленного времени, изменение профиля постобработки и высоты звука. Затем запускается корутина для восстановления нормального времени.
Метод ContinueTime сбрасывает флаги IsTimeStopped и IsTimeSlowed, переводит все объекты обратно в состояние нормального времени, восстанавливает профиль постобработки, отключает камеру манипуляции временем и восстанавливает высоту звука и громкость.
TimeManager ведет список объектов, на которые влияют манипуляции временем. Объекты добавляются в список через метод AddTimeBody и удаляются через RemoveTimeBody. При манипуляциях временем скрипт проверяет, не являются ли объекты в списке null, и удаляет их при необходимости, чтобы избежать ошибок.
Перед выполнением остановки или замедления времени проверяется текущее состояние времени, чтобы избежать конфликтов. В процессе работы скрипт постоянно проверяет объекты на null, удаляя их из списка при необходимости. Также, если экземпляр TimeManager еще не создан, запускается корутина, которая ждет его создания и затем добавляет объект в менеджер.
TimeManager координирует глобальные изменения времени в игре, обеспечивая синхронизацию визуальных и звуковых эффектов, что делает манипуляции временем плавными и логичными для игрока, например, при остановке времени все звуки замедляются, это возможно благодаря компоненту AudioSource в Unity, который позволяет изменять параметр тона звука, что при снижении значения замедляет и понижает тональности звука, что создаёт эффект замедленного или остановленного времени. Также помогает работа с настройками рендеринга, реализованными во встроенном решении от Unity – Universal Render Pipeline. Благодаря этому решению во время остановки времени меняются параметры пост-процессинга, что делает картинку чёрно-белой и создаёт необходимую атмосферу изменённого пространства.
TimeBody, представленный в листинге А.13, начинает с инициализации компонента ITimeAffected, который продемонстрирован в листинге А.14 и реализует методы для различных состояний времени. При включении объекта (метод OnEnable), TimeBody добавляет себя в TimeManager и подписывается на события уничтожения объекта, чтобы корректно удалить себя из менеджера при уничтожении.
Когда объект активируется, он добавляет себя в TimeManager через метод AddToTimeManager. Если TimeManager еще не создан, запускается корутина, ожидающая его создания и затем добавляющая объект в менеджер.
При отключении или уничтожении объекта TimeBody удаляет себя из TimeManager с помощью метода RemoveFromTimeManager, чтобы избежать утечек памяти и ошибок.
TimeBody реализует методы для различных состояний времени, вызывая соответствующие методы интерфейса ITimeAffected:
-	SetRealTime: переводит объект в нормальное время;
-	SetStopTime: останавливает время для объекта;
-	SetSlowTime: замедляет время для объекта;
-	SetAcceleratedTime: ускоряет время для объекта;
-	SetRewindTime: перематывает время для объекта.
В зависимости от текущего состояния времени в TimeManager, TimeBody применяет соответствующее состояние к объекту. Например, если время остановлено, вновь добавленный объект также будет остановлен.
TimeBody подписывается на событие уничтожения объекта через ITimeAffected. Это позволяет своевременно удалить объект из TimeManager, предотвращая ошибки при попытке доступа к несуществующему объекту.
Скрипт проверяет наличие TimeManager и корректно обрабатывает случаи его отсутствия при активации объекта. Кроме того, TimeBody следит за корректным удалением себя из менеджера, подписываясь и отписываясь от событий уничтожения объекта.
Система перемотки времени в игре позволяет игроку воздействовать на объекты, перемещая их состояния назад во времени. Эта механика реализована через различные классы, которые взаимодействуют между собой для достижения плавного и интерактивного игрового опыта.
Рассмотрим основные компоненты системы перемотки временем, представленные в таблице 5 и их взаимодействие, представленное на рисунке 5.
Таблица 5 – Описание классов системы перемотки времени
Класс	Роль
RecallSpell		Управляет процессом применения навыка перемотки времени. Обнаруживает и подготавливает объекты для перемотки, запускает таймер и отменяет способность по запросу игрока.
RecallSpellMediator	Медиатор между RecallSpell и внешними компонентами. Отвечает за визуализацию таймера и другие пользовательские интерфейсы, реагируя на события начала, применения и отмены способности.
Recorder	Записывает и восстанавливает состояния объектов. Обеспечивает плавное перемещение объектов во времени и управление паузой.
SpellCaster	Обрабатывает ввод игрока и инициирует или отменяет способность перемотки времени.
RecallInteractor	Подготавливает и активирует режим перемотки времени для конкретных объектов. Реагирует на команды от RecallSpell и управляет состоянием объектов.
RecordBuffer	Хранит и управляет записями состояний объектов для восстановления во времени.

 
Рисунок 5 – Диаграмма классов перемотки временем

Конструктор класса RecallSpell, который представлен в листинге А.16, принимает на вход конфигурацию для способности и таймер, который используется для отслеживания времени. Также устанавливается объект, который используется в качестве источника информации для перемотки (в данном случае, персонаж).
Метод StartCast запускается, когда игрок решает использовать способность. Он проходит через область, определенную радиусом, и обнаруживает объекты, способные быть перемотанными.
После обнаружения объектов, метод Prepare вызывается для каждого найденного объекта. Это происходит для того, чтобы объекты подготовились к перемотке времени, например, выведя специальные визуальные эффекты.
Если игрок решает применить способность, вызывается метод TryApplyCast. Этот метод активирует режим перемотки времени для каждого найденного объекта. Также запускается таймер, который отслеживает, сколько времени прошло с момента активации.
Если способность была отменена игроком или время закончилось, вызывается метод CancelCast. Это приводит к деактивации режима перемотки времени для всех объектов и сбросу таймера.
В различных этапах процесса применения способности генерируются события, такие как CastStarted, CastApplied, CastCanceled и т. д. Эти события используются для взаимодействия с другими компонентами игры, например, для обновления интерфейса или визуализации.
Когда создается экземпляр RecallSpellMediator, представленный в 
листинге А.17, ему передаются три параметра: экземпляр способности перемотки времени (RecallSpell), входные действия игрока (PlayerInputActions) и представление таймера (TimerView). Конструктор подписывается на события, генерируемые объектом RecallSpell, такие как CastStarted (вызывается, когда начинается применение способности), CastCanceled (вызывается, когда способность отменена), CastApplied (вызывается, когда способность применена к объекту) и CastPerformed (вызывается, когда способность завершена).
Скрипт содержит методы для обработки этих событий и обновления пользовательского интерфейса. Метод OnCastApplied вызывается, когда способность успешно применена к объекту. В этом методе вызывается TimerView.Show, который отображает таймер на экране, используя информацию о перематываемом объекте.
Метод OnCastPerformed вызывается, когда способность завершена. В этом методе вызывается TimerView.Hide, чтобы скрыть таймер с экрана.
Для освобождения ресурсов используется метод Dispose, который отписывается от всех событий способности. Это необходимо для предотвращения утечек памяти и других проблем, связанных с подписками на события. Этот метод должен быть вызван, когда объект RecallSpellMediator больше не нужен.
Таким образом, RecallSpellMediator выполняет роль связующего звена между логикой способности перемотки времени и пользовательским интерфейсом. Он слушает события от способности, управляет отображением таймера и другими визуальными эффектами, обеспечивая взаимодействие пользователя с механикой перемотки времени.
Скрипт SpellCaster, продемонстрированный в листинге А.19, управляет процессом использования способности перемотки времени игроком. Основная его задача – обрабатывать ввод игрока и инициировать действия способности в зависимости от этих вводов. В начале скрипт получает ссылку на объект способности (RecallSpell) и объект, управляющий вводом игрока (PlayerInputActions). Эти объекты передаются через метод Construct, который используется для инициализации. В этом методе SpellCaster связывается с экземплярами RecallSpell и PlayerInputActions, а затем подписывается на событие нажатия клавиши, отвечающей за начало перемотки времени.
Когда игрок нажимает клавишу, запускающую перемотку времени, вызывается метод OnCastSpellKeyPressed. Этот метод проверяет, активна ли способность, используя свойство _recallSpell.IsApplied. Если способность не активна, запускается процесс её применения. Метод _recallSpell.StartCast инициирует поиск объектов, на которые может воздействовать способность. Затем вызывается метод OnCastAppliedKeyPressed для продолжения применения способности. Если способность уже активно, вызывается метод OnCastCanceledKeyPressed, который отменяет её.
Метод OnCastAppliedKeyPressed вызывается, когда игрок применяет способность. Внутри этого метода проверяется, удалось ли применить способность через вызов _recallSpell.TryApplyCast. Если способность успешно применена, выводится сообщение в консоль, обработчик нажатия клавиши применения способности отписывается, и подписывается обработчик события завершения способности.
Метод OnCastCanceledKeyPressed вызывается, когда игрок отменяет способность. В этом методе выводится сообщение в консоль, подписывается обработчик события отмены способности, и вызывается метод _recallSpell.CancelCast для его отмены.
Метод OnCastCanceled вызывается при отмене способности. Внутри этого метода отписываются обработчики событий отмены и завершения способности, и снова подписывается обработчик нажатия клавиши для начала перемотки времени.
Метод OnCastPerformed вызывается при завершении способности. В этом методе отписывается обработчик нажатия клавиши для отмены способности, отписываются обработчики событий отмены и завершения способности, и снова подписывается обработчик нажатия клавиши для начала перемотки времени.
Таким образом, скрипт SpellCaster обеспечивает взаимодействие игрока с способностью перемотки времени, обрабатывая ввод и управляя состояниями способности, такими как начало, применение, отмена и завершение.
Скрипт RecallInteractor, представленный в листинге А.20, управляет взаимодействием объектов с механизмом перемотки времени. Он предназначен для подготовки, активации и деактивации объектов, которые будут взаимодействовать с способностью перемотки времени. Основные элементы этого скрипта включают список записывающих компонентов (IRecorder), визуализатор для отображения состояния взаимодействия, а также методы для управления состояниями объектов.
При инициализации, в методе Start, скрипт находит все компоненты, реализующие интерфейс IRecorder, прикрепленные к объекту. Если таких компонентов нет, выбрасывается исключение, чтобы указать на проблему в настройке объекта.
Метод Prepare используется для подготовки объекта к взаимодействию с способностью. Он вызывает метод ShowPreparation визуализатора, чтобы отобразить состояние подготовки объекта. Это может включать изменение внешнего вида объекта, чтобы игрок знал, что объект готов к взаимодействию.
Метод Activate отвечает за активацию объекта для взаимодействия с способностью перемотки времени. При активации вызывается метод ShowActivation визуализатора, который изменяет внешний вид объекта, чтобы показать его активное состояние. Затем для каждого записывающего компонента вызывается метод StartRewind, который инициирует процесс перемотки времени. Это позволяет объектам начать воспроизводить свои предыдущие состояния.
Метод Deactivate используется для деактивации объекта, когда взаимодействие с способностью завершено или отменено. Он вызывает метод Hide визуализатора, чтобы вернуть объект в его обычное состояние. После этого для каждого записывающего компонента вызывается метод StartRecord, который снова запускает процесс записи текущих состояний объекта.
Таким образом, RecallInteractor является ключевым компонентом системы перемотки времени, который управляет подготовкой, активацией и деактивацией объектов, а также контролирует их визуальное представление и взаимодействие с процессом записи и воспроизведения состояний.
Скрипт Recorder, представленный в листинге А.18, представляет собой абстрактный класс, который отвечает за запись и воспроизведение изменений состояния объектов в игре. Этот класс предназначен для использования в механике перемотки времени. Он реализует интерфейсы IRecorder и IPause, что позволяет ему управлять процессами записи и воспроизведения, а также поддерживать возможность паузы.
Основные события, которые обрабатывает Recorder, включают InterpolatedValue, RestoredValue и DataHasEnded. Эти события позволяют внешним объектам подписываться на уведомления о изменении интерполированных значений, восстановлении значений и завершении данных соответственно.
В классе Recorder определены две константы: NumberOfSkippedFrames, которая задает количество пропускаемых кадров между записями, и _recordFramesCounter и _rewindFramesCounter, которые отслеживают количество прошедших кадров при записи и перемотке.
Поле _currentValue хранит текущее значение, а _targetValue – целевое значение, к которому идет интерполяция. Поле _buffer представляет собой буфер для хранения записанных значений. Оно инициализируется в методе Construct, который принимает конфигурацию способности и обработчик пауз. Буфер настраивается на хранение данных за определенное количество секунд, заданное в конфигурации.
Методы StartRecord и StartRewind управляют началом записи и перемотки соответственно. Метод SetPause позволяет ставить запись на паузу и снимать её.
Метод FixedUpdate управляет основным циклом обновления, где происходит либо запись значений, либо их воспроизведение. Если объект находится в режиме записи и количество пропущенных кадров достигло заданного значения, текущее значение записывается в буфер. Если объект находится в режиме перемотки, то через заданные интервалы считываются записанные значения и производится интерполяция между текущим и целевым значениями.
Метод ReadNewValue отвечает за чтение следующего значения из буфера. Если данные заканчиваются, вызывается событие DataHasEnded.
В классе также определены два абстрактных метода: GetRecordValue, который возвращает текущее значение для записи, и RestoreValue, который интерполирует между текущим и целевым значениями. Метод IsDataValuesChanged проверяет, изменилось ли значение, чтобы избежать излишних записей.
В конкретных реализациях этого класса, таких как TransformRecorder и VelocityRecorder, эти абстрактные методы переопределяются для работы с конкретными типами данных, например, с данными, которые предоставляет нам Unity благодаря своим компонентам – с позициями и вращениями объектов, скоростями и угловыми скоростями и т.д.
Данный класс универсален и способен работать со множеством данных, достаточно лишь реализовать скрипт наследник от класса Recorder, который должен записывать те данные, которые нам необходимы. Таким образом, класс Recorder обеспечивает универсальную основу для записи и воспроизведения изменений состояния объектов, что является ключевым элементом в механике перемотки времени. 
Скрипт RecordBuffer<RecordableValue>, который продемонстрирован в листинге А.21, представляет собой буфер для хранения записанных значений состояния объекта за определенный промежуток времени. Этот буфер используется в механизме перемотки времени для записи и воспроизведения состояний объекта. Основные элементы этого скрипта включают список записываемых значений (_recordableValues), максимальную емкость буфера, а также методы для записи новых значений и чтения последних записанных значений.
Когда буфер создается через конструктор RecordBuffer он инициализирует свою емкость и создает пустой список для хранения записываемых значений. Емкость буфера указывается при создании и должна быть положительным числом; в противном случае выбрасывается исключение.
Метод Write добавляет новое записываемое значение в буфер. Если буфер уже заполнен, самое старое значение удаляется из конца списка, чтобы освободить место для нового значения. Новое значение затем добавляется в начало списка.
Метод TryReadLastValue используется для чтения последнего записанного значения из буфера. Если буфер пуст (то есть в списке нет записываемых значений), метод возвращает false, а выходной параметр value получает значение по умолчанию для типа RecordableValue. Если в буфере есть значения, метод извлекает последнее записанное значение из начала списка, удаляет его из буфера и возвращает true, указывая, что чтение прошло успешно.
С помощью этих методов буфер управляет процессом записи и воспроизведения состояний объектов. В процессе записи каждое новое значение добавляется в буфер, поддерживая актуальную историю состояний объекта. В процессе воспроизведения значения извлекаются из буфера в обратном порядке, что позволяет объекту возвращаться к своим предыдущим состояниям.
Таким образом, RecordBuffer<RecordableValue> играет ключевую роль в механизме перемотки времени, обеспечивая хранение и управление историей состояний объекта, которые могут быть записаны и воспроизведены по мере необходимости.
